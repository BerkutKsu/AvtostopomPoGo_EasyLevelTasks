package main

import (
	"fmt"
	"time"
  "sync" //добавили
)

// time.Sleep использовать нельзя. это будет не валидным ответом на собеседовании
// 1
// Что выведет код и почему?
//// выведет не то, что мы ожидаем (1000), а при каждом запуске программы разный результат (979, 992, 986 и т.д.), потому что main
    завершается раньше, чем заканчивают отрабатывать все запущенные рутины и с другой стороны
    потому что у нас параллельно несколько рутин считывают одинаковое значение и увеличивают его на единицу
// Как исправить?
//// т.к. time.Sleep нам не подходит, необходимо импортировать пакет sync и использовать WaitGroup + Mutex
func main() {
	var counter int
	// for i := 0; i < 1000; i++ {
	// 	go func() {
	// 		counter++
	// 	}()
	// }
  var wg sync.WaitGroup
	var mu sync.Mutex
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			mu.Lock()
			counter++
			mu.Unlock()
		}()
	}
	wg.Wait()
	fmt.Println(counter)
}

// 2
// Что выведет код и почему?
//// выведет ошибку с дэдлоком, потому что в момент записи значения 1 в канал у нас нет свободных горутин, куда можно переключиться
// Как исправить оставив канал небуферезированным?
//// необходимо в принимаемом аргументе анонимной функции указать (ch chan int) и передать в нее ch и только после этого вызвать запись в канал.
    Еще желательно в конце добавить sync.WaitGroup.Wait(). Иначе не факт, что горутина успеет отработать
func main() {
	ch := make(chan int)
	//ch <- 1
	go func(ch chan int) {
		fmt.Println(<-ch)
	}(ch)
  ch <- 1
  var wg sync.WaitGroup
	wg.Wait()
}

// 3
// Расскажи подробно что происходит?(спойлер: почему будет panic?)
//// мы получаем ошибку из-за того, что у нас одновременно несколько рутин пытаются записать значения в мапу
// Как сделать так, чтобы работало?
//// необходимо использовать mutex в каждой анонимной функции и заменить time.Sleep на WaitGroup
func main() {
	x := make(map[int]int, 1)
  var mu sync.Mutex
	var wg sync.WaitGroup
	wg.Add(10)
	go func() {
    defer wg.Done()
		mu.Lock()
    x[1] = 2
    mu.Unlock()
  }() // и так делаем для каждой анонимной функции
	go func() { x[3] = 7 }()
	go func() { x[123] = 10 }()
	go func() { x[1] = 2 }()
	go func() { x[34] = 7 }()
	go func() { x[1432] = 10 }()
	go func() { x[1] = 2 }()
	go func() { x[100] = 7 }()
	go func() { x[34] = 10 }()
	go func() { x[1] = 2 }()
	//time.Sleep(100 * time.Millisecond) //блокируемся на 100 миллисекунд
  wg.Wait()
	fmt.Println("x[1] =", x[1])
}
